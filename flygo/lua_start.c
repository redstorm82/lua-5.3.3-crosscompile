#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
//lua头文件
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#define err_exit(num,fmt,args)  \
    do{printf("[%s:%d]"fmt"\n",__FILE__,__LINE__);getchar();exit(num);} while(0)
#define err_return(num,fmt,args)  \
    do{printf("[%s:%d]"fmt"\n",__FILE__,__LINE__);getchar();return(num);} while(0)

extern int luaopen_cjson(lua_State *l);

#if !defined(LUA_PROGNAME)
#define LUA_PROGNAME		"lua"
#endif

static lua_State *globalL = NULL;
static const char *progname = LUA_PROGNAME;
/*
** Hook set by signal function to stop the interpreter.
*/
static void lstop (lua_State *L, lua_Debug *ar) {
  (void)ar;  /* unused arg. */
  lua_sethook(L, NULL, 0, 0);  /* reset hook */
  luaL_error(L, "interrupted!");
}


/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void laction (int i) {
  signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
}

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message (const char *pname, const char *msg) {
  if (pname) lua_writestringerror("%s: ", pname);
  lua_writestringerror("%s\n", msg);
}


/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}


/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                               luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}


/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  globalL = L;  /* to be available to 'laction' */
  signal(SIGINT, laction);  /* set C-signal handler */
  status = lua_pcall(L, narg, nres, base);
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  lua_remove(L, base);  /* remove message handler from the stack */
  return status;
}

//lua中调用的c函数定义,实现加法
int csum(lua_State* l)
{
	int a = lua_tointeger(l, 1);
	int b = lua_tointeger(l, 2);
	/* push result */
	lua_pushinteger(l, a + b);

	/* 这里可以看出，C可以返回给Lua多个结果，
	* 通过多次调用lua_push*()，之后return返回结果的数量。
	*/
	return 1;  /* number of results */
}
int main(int argc, char** argv)
{
	lua_State * l = luaL_newstate();        //创建lua运行环境
	/* open standard libraries */
	luaL_openlibs(l);
	luaopen_cjson(l);
	lua_gettop(l);
	if (l == NULL) err_return(-1, "luaL_newstat() failed","");
	int ret = 0;
	ret = luaL_loadfile(l, "func.lua");      //加载lua脚本文件
	if (ret != 0) {
		report(l, ret);
		err_return(-1, "luaL_loadfile failed", "");
	}
	ret = lua_pcall(l, 0, 0, 0);
	if (ret != 0) {
		report(l, ret);
		err_return(-1, "lua_pcall failed:%s", lua_tostring(l, -1));
	}

	lua_getglobal(l, "width");              //获取lua中定义的变量
	lua_getglobal(l, "height");
	int width = lua_tointeger(l, -1);
	int height = lua_tointeger(l, -2);
	printf("height:%ld width:%ld\n", height, width);
	lua_pop(l, 1);                        //恢复lua的栈

	int a = width;
	int b = height;
	lua_getglobal(l, "sum");               //调用lua中的函数sum
	lua_pushinteger(l, a);
	lua_pushinteger(l, b);
	ret = lua_pcall(l, 2, 1, 0);
	if (ret != 0) err_return(-1, "lua_pcall failed:%s", lua_tostring(l, -1));
	printf("sum:%d + %d = %ld\n", a, b, lua_tointeger(l, -1));
	lua_pop(l, 1);

	const char str1[] = "call lua func mystrcat";
	const char str2[] = " from C code";
	
	lua_getglobal(l, "mystrcat");          //调用lua中的函数mystrcat
	lua_pushstring(l, str1);
	lua_pushstring(l, str2);
	ret = lua_pcall(l, 2, 1, 0);
	if (ret != 0) err_return(-1, "lua_pcall failed:%s", lua_tostring(l, -1));
	printf("call mystrcat(%s + %s ) = %s\n", str1, str2, lua_tostring(l, -1));
	lua_pop(l, 1);

	/* 这两句话还有更简单的方法：
	* lua_register(l, "csum", csum)
	* 将C函数"csum"定义为Lua的全局变量"csum"。
	* 其实现是如下宏：
	* #define lua_register(L,n,f) \
	*      (lua_pushcfunction(L, f), lua_setglobal(L, n))
	*/
	lua_pushcfunction(l, csum);         //注册在lua中使用的c函数
	lua_setglobal(l, "csum");           //绑定到lua中的名字csum
	

	lua_getglobal(l, "mysum");           //调用lua中的mysum函数，该函数调用本程序中定义的csum函数实现加法
	lua_pushinteger(l, a);
	lua_pushinteger(l, b);
	ret = lua_pcall(l, 2, 1, 0);
	if (ret != 0) err_return(-1, "lua_pcall failed:%s", lua_tostring(l, -1));
	printf("mysum:%d + %d = %ld \n", a, b, lua_tointeger(l, -1));
	lua_pop(l, 1);
	
	//调用lua中的main_start函数，该函数为lua脚本的入口函数，控制所有业务执行逻辑。
	lua_getglobal(l, "main_start");         
	lua_pushinteger(l, a);
	lua_pushinteger(l, b);
	printf("will call main_start:%d + %d\n", a, b);
	ret = lua_pcall(l, 2, 1, 0);
	if (ret != 0) err_return(-1, "lua_pcall failed:%s", lua_tostring(l, -1));
	printf("mysum:result %ld \n",lua_tointeger(l, -1));
	lua_pop(l, 1);

	lua_close(l);                     //释放lua运行环境
	return 0;
}



